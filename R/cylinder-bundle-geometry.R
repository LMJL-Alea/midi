#' Generates a cross section of a cylinder bundle
#'
#' Generates a cross section of a cylinder bundle with a given density and voxel
#' size. The cross section is generated by simulating a random distribution of
#' cylinders and computing the intersection of the cylinders with a plane. The
#' radii of the cylinders are drawn from a Gamma distribution fitted from data
#' retrieved by histology in the genu of the corpus callosum (Aboitiz et al.,
#' 1992). The number of cylinders is determined by the density and the voxel
#' size.
#'
#' @param density A numeric value between 0 and 1 specifying the density of the
#'   cylinders in the voxel. Defaults to `0.9`.
#' @param voxel_size A numeric value specifying the size of the voxel in meters.
#'   Defaults to `1e-5`.
#' @param max_iter An integer value specifying the maximum number of iterations
#'   for the simulation. Defaults to `1000L`.
#'
#' @return A list with the following components:
#' - `sections`: A [`tibble::tibble`] with the following columns:
#'   - `x`: The x-coordinates of the centers of the cylinders;
#'   - `y`: The y-coordinates of the centers of the cylinders;
#'   - `r`: The radii of the cylinders.
#' - `voxel_size`: The size of the voxel in meters.
#' @export
#'
#' @examples
#' density <- 0.9
#' voxel_size <- 0.000010 # 10 micrometers
#' out <- simulate_bundle(density, voxel_size)
#'
#' # Actual density in the simulated substrate
#' sum(out$sections$r^2 * pi) / voxel_size^2
simulate_bundle <- function(density = 0.9, voxel_size = 1e-5, max_iter = 1000L) {
  kappa <- 5.3316
  scale <- 1.0242e-7
  rad_mean <- kappa * scale
  mean_cyl_surf <- pi * rad_mean^2
  n_cylinders <- round(density * voxel_size^2 / mean_cyl_surf)
  radii <- sort(
    stats::rgamma(n_cylinders, shape = kappa, scale = scale),
    decreasing = TRUE
  )
  tot_surf <- 0
  grd <- seq(0, 2 * pi, length.out = 100)
  unit_circle_sample <- cbind(cos(grd), sin(grd))
  x_centers <- rep(NA, n_cylinders)
  y_centers <- rep(NA, n_cylinders)
  for (i in 1:n_cylinders) {
    ok <- FALSE
    r <- radii[i]
    iter <- 0
    while (!ok && iter < max_iter) {
      x <- stats::runif(1, min = -voxel_size / 2, max = voxel_size / 2)
      y <- stats::runif(1, min = -voxel_size / 2, max = voxel_size / 2)
      points <- cbind(
        x + r * unit_circle_sample[, 1],
        y + r * unit_circle_sample[, 2]
      )
      ok <- all(points <= voxel_size / 2) && all(points >= -voxel_size / 2)
      if (i > 1) {
        for (j in 1:(i - 1)) {
          if (any((points[, 1] - x_centers[j])^2 +
                  (points[, 2] - y_centers[j])^2 < radii[j]^2)) {
            ok <- FALSE
            break
          }
        }
      }
      iter <- iter + 1
    }
    if (!ok) radii[i] <- 0
    tot_surf <- tot_surf + pi * radii[i]^2
    if (tot_surf > density * voxel_size^2) {
      break
    }
    x_centers[i] <- x
    y_centers[i] <- y
  }

  df <- tibble::tibble(x = x_centers, y = y_centers, r = radii)
  df <- tidyr::drop_na(df)
  out <- list(sections = df, voxel_size = voxel_size)
  class(out) <- c("bundle", class(out))
  out
}

#' Plots a cross section of a cylinder bundle using `ggplot2`
#'
#' Plots a cross section of a cylinder bundle from an object of class `bundle`
#' as generated by [`simulate_bundle()`] using `ggplot2`.
#'
#' @param object An object of class `bundle` as generated by
#'   [`simulate_bundle()`].
#' @param grid_size An integer value specifying the number of points on which
#'   the unit circle should be discretized to draw the spheres. Defaults to
#'   `100L`.
#' @param ... Additional arguments to be passed to the [`ggplot2::autoplot()`]
#'   method.
#'
#' @return A [`ggplot2::ggplot()`] object.
#' @export
#'
#' @importFrom ggplot2 autoplot
#' @importFrom rlang .data
#' @examples
#' density <- 0.9
#' voxel_size <- 0.000010 # 10 micrometers
#' out <- simulate_bundle(density, voxel_size)
#' ggplot2::autoplot(out)
autoplot.bundle <- function(object, grid_size = 100L, ...) {
  grd <- seq(0, 2 * pi, length.out = grid_size)
  voxel_size <- object$voxel_size
  sections <- object$sections |>
    purrr::array_tree(margin = 1) |>
    purrr::imap(\(vals, id) {
      res <- tibble::tibble(
        x = vals[1] + vals[3] * cos(grd),
        y = vals[2] + vals[3] * sin(grd)
      )
      res$id <- id
      res
    })
  sections <- do.call(rbind, sections)
  sections |>
    ggplot2::ggplot(ggplot2::aes(.data$x, .data$y)) +
    ggplot2::geom_polygon(ggplot2::aes(group = .data$id)) +
    ggplot2::geom_hline(yintercept = -voxel_size / 2, color = "black") +
    ggplot2::geom_hline(yintercept =  voxel_size / 2, color = "black") +
    ggplot2::geom_vline(xintercept = -voxel_size / 2, color = "black") +
    ggplot2::geom_vline(xintercept =  voxel_size / 2, color = "black") +
    ggplot2::theme_void() +
    ggplot2::coord_equal() +
    ggplot2::theme(legend.position = "none")
}

#' Plots a cross section of a cylinder bundle
#'
#' @param x An object of class `bundle` as generated by
#'   [`simulate_bundle()`].
#' @inheritParams autoplot.bundle
#'
#' @return Nothing.
#' @export
#'
#' @importFrom graphics plot
#' @examples
#' density <- 0.9
#' voxel_size <- 0.000010 # 10 micrometers
#' out <- simulate_bundle(density, voxel_size)
#' plot(out)
plot.bundle <- function(x, grid_size = 100L, ...) {
  print(autoplot(x, grid_size, ...))
}

#' Plots a 3D representation of a cylinder bundle using `rgl`
#'
#' Plots a 3D representation of a cylinder bundle from an object of class
#' `bundle` as generated by [`simulate_bundle()`] using `rgl`.
#'
#' @param x An object of class `bundle` as generated by
#'   [`simulate_bundle()`].
#' @param widget A logical value indicating whether to return an HTML widget for
#'   reporting. Defaults to `FALSE`.
#' @param ... Additional arguments to be passed to the [`rgl::plot3d()`]. Not
#'   used here.
#'
#' @return If `widget` is `TRUE`, an HTML widget is returned. Otherwise,
#'   nothing.
#' @export
#'
#' @importFrom rgl plot3d
#' @examples
#' density <- 0.9
#' voxel_size <- 0.000010 # 10 micrometers
#' out <- simulate_bundle(density, voxel_size)
#' rgl::plot3d(out)
plot3d.bundle <- function(x, widget = FALSE, ...) {
  cylinders <- x$sections[, c("x", "y")] |>
    purrr::array_tree(margin = 1) |>
    purrr::map(\(v) tidyr::crossing(
      tibble::tibble(x = v[1], y = v[2]),
      z = c(0, 1)
    ))
  radii <- x$sections$r
  rglcylinders <- purrr::map2(cylinders, radii, \(.cylinder, .radius) {
    cyl <- rgl::cylinder3d(
      center = .cylinder,
      radius = .radius,
      sides = 64,
      closed = -2)
    cyl$material$alpha <- 0.3
    cyl$material$color <- "blue"
    cyl$materal$specular <- "black"
    cyl
  })

  try(rgl::close3d(), silent = TRUE)

  if (!widget)
    rgl::open3d()

  rgl::shade3d(rgl::shapelist3d(rglcylinders, plot = FALSE))
  rgl::axes3d(edges = c("x", "y", "z"))
  rgl::aspect3d(1, 1, 1)

  if (widget)
    rgl::rglwidget()
}
